# 클로저(Closure)

> 클로저는 함수와 그 함수가 선언된 어휘적 환경(Lexical Environment)의 조합이다.

MDN 에서는 클로저에 대해 위와 같이 정의하고 있다.

위 정의만 봐서는 클로저가 정확히 어떤 개념인지 이해하기 어렵다.

클로저는 실행 컨텍스트의 어휘적 환경(렉시컬 환경)과 밀접한 연관이 있기 때문에 이에 대해 먼저 알아보자.

<br>

## 렉시컬 환경(Lexical Environment)

렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 바인딩된 값을 관리하며 상위 스코프에 대한 참조를 저장하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.

자바스크립트의 함수는 어디서 정의했는지에 따라 상위 스코프를 결정하는데 이를 렉시컬 스코프(정적 스코프)라고 한다.

즉, 렉시컬 환경은 렉시컬 스코프의 실체다.

```js
const x = 1;

const foo = () => {
  const x = 10;
  bar();
};

const bar = () => {
  console.log(x);
};

foo(); // 1
bar(); // 1
```

함수 foo와 bar는 전역에서 정의된 함수다.

따라서 foo 함수와 bar 함수의 상위 스코프는 전역이기 때문에 전역 변수 x를 참조할 수 있다. 또한 foo 함수 내부에서 bar 함수를 호출한다고 해서 bar 함수의 상위 스코프 결정에는 아무 영향이 없다.

위 내용을 정리해 보면 모든 함수는 렉시컬 환경을 갖기 때문에 클로저라고 할 수 있다.

하지만 일반적으로 모든 함수를 클로저라고 하지는 않는다.

<br>

## 실용적인 클로저

```js
const foo = () => {
  const x = 1;

  const bar = () => {
    console.log(x);
  };

  return bar;
};

const func = foo();
func(); // 1

console.dir(func);
```

![클로저](https://github.com/chanyDev/TIL/blob/main/img/JS/%ED%81%B4%EB%A1%9C%EC%A0%80.PNG?raw=true)

개발자 도구를 통해 위 코드를 확인하면 클로저임을 확인할 수 있다.

위 예제의 foo 함수의 실행 컨텍스트는 bar 함수를 반환하고 실행 컨텍스트 스택에서 pop 된다.

bar함수를 할당한 func 함수를 호출하면 console에 1을 출력한다. 이처럼 종료된 실행 컨텍스트의 스코프의 변수가 참조 가능한 이유는 실행 컨텍스트가 제거되더라도 렉시컬 환경까지 제거되는 것은 아니기 때문이다.

즉, 가비지 컬렉터는 참조되고 있는 메모리 공간을 함부로 해제하지 않는다.

그렇다면 상위 스코프의 변수를 참조하지 않는다면 어떨까?

```js
const foo = () => {
  const x = 1;

  const bar = () => {
    const y = 2;
    console.log(y);
  };

  return bar;
};

const func = foo();
func();

console.dir(func);
```

![클로저가 아닌 함수](https://github.com/chanyDev/TIL/blob/main/img/JS/%ED%81%B4%EB%A1%9C%EC%A0%80%EA%B0%80%20%EC%95%84%EB%8B%8C%20%ED%95%A8%EC%88%98.PNG?raw=true)

개발자 도구를 통해 확인하면 클로저가 아님을 확인할 수 있다.

이처럼 보여지는 이유는 모던 브라우저에서는 최적화를 통해 참조되지 않는 식별자를 기억하지 않는다.

따라서 클로저는 다음 두가지 조건을 충족하는 경우에 한정하는 것이 일반적이다.

1. 중첩 함수가 상위 스코프의 식별자를 참조하는 경우
2. 중첩 함수가 외부 함수보다 생명주기가 긴 경우

<br>

### 참고 자료

📙 모던 자바스크립트 Deep Dive <br>
https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures
