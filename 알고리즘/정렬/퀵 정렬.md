# 퀵 정렬(Quick Sort)

> 퀵 정렬은 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.

비교 정렬 : 비교 정렬은 원소들을 정렬할 때 원소들의 순서에만 의존하는 알고리즘을 뜻한다. 예를 들어
[버블 정렬](https://github.com/chanyDev/TIL/blob/main/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%A0%95%EB%A0%AC/%EB%B2%84%EB%B8%94%20%EC%A0%95%EB%A0%AC.md)은 비교하는 원소들이 숫자거나, 문자열이거나, 복잡한 객체에 대해서도 순서가 결정되어 있다면 적용할 수 있다.

<br>

![퀵 정렬](https://github.com/chanyDev/TIL/blob/main/img/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%A0%95%EB%A0%AC/%ED%80%B5%20%EC%A0%95%EB%A0%AC.gif?raw=true)

<br>

## 특징

- 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교해도 속도가 가장 빠르다.
- 추가 메모리을 따로 사용하지 않는 in place 방법으로 구현하는 것이 일반적이다.
- not stable 알고리즘이다.
- [분할 정복 알고리즘](https://github.com/chanyDev/TIL/blob/main/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%A0%95%EB%A0%AC/%EB%B3%91%ED%95%A9%20%EC%A0%95%EB%A0%AC.md#%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98divide-and-conquer-algorithm)을 통해 리스트를 정렬한다.

<br>

## Big O

- Worst Case: O(n^2)
- Best Case: O(nlog₂n)

정렬된 리스트에 대해서는 불균형 분할에 의해 오히려 수행시간이 오래 걸린다.

<br>

## 구현

퀵 정렬은 하나의 기준 데이터를 고르고 이 데이터를 **피벗(pivot)** 이라고 한다. <br>
피벗 앞에는 피벗보다 값이 작은 데이터들이 오고, 피벗 뒤에는 피벗보다 값이 큰 데이터들이 오도록 피벗을 기준으로 데이터를 둘로 나눈다. <br>
피벗을 기준으로 좌 우로 이분화 된 리스트를 재귀적으로 반복했을 때 결국 정렬이 완성된다는 방법론이다. <br>
재귀 함수는 현재 리스트의 데이터 개수가 1개인 경우 정렬이 되어있다고 간주하여 종료한다.

좀 더 이해하기 쉽게 3개 파트로 나눠서 살펴보자.

1. 리스트의 첫 번째 데이터를 피벗으로 설정하고 왼쪽에서부터 피벗보다 큰 데이터를 선택하고 오른쪽에서부터 피벗보다 작은 데이터를 선택하고 두 데이터의 위치를 서로 변경한다. 이때 왼쪽의 값이 작고 오른쪽의 값이 크다면 작은 데이터와 피벗의 위치를 변경한다. 완료되면 피벗을 기준으로 좌측에는 피벗보다 작은 데이터들이 우측에는 피벗보다 큰 데이터들이 모이게 된다.
2. 왼쪽 리스트들 또한 피벗을 설정하여 1번의 과정을 수행한다.
3. 오른쪽 리스트들 또한 피벗을 설정하여 1번의 과정을 수행한다.

위 과정을 코드로 구현하면 다음과 같다.

```js
const quickSort = (array, start, end) => {
  // 데이터가 1개인 경우 종료
  if (start >= end) return;

  // 첫 번째 데이터를 피벗으로 설정
  const pivot = start;
  // 리스트의 좌, 우측 시작점
  let left = start + 1;
  let right = end;
  // 피벗을 기준으로 좌측에는 작은 데이터가, 우측에는 큰 데이터가 올 때까지 반복
  while (left <= right) {
    // 피벗보다 큰 데이터를 찾을때까지 반복
    while (left <= end && array[left] <= array[pivot]) {
      left++;
    }
    // 피벗보다 작은 데이터를 찾을때까지 반복
    while (right > start && array[right] >= array[pivot]) {
      right--;
    }
    // 작은 데이터와 큰 데이터의 위치 변경
    if (right > left) {
      let swap = array[left];
      array[left] = array[right];
      array[right] = swap;
    }
    // 리스트 왼쪽의 값이 작고 오른쪽의 값이 크다면 작은 값과 피벗의 위치 변경
    else {
      let swap = array[right];
      array[right] = array[pivot];
      array[pivot] = swap;
    }
  }
  // 피벗을 기준으로 좌, 우로 위치된 데이터들에 대해 각각 정렬
  quickSort(array, start, right - 1);
  quickSort(array, right + 1, end);

  return array;
};

const array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8];

console.log(quickSort(array, 0, array.length - 1)); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

<br>

### 참고 자료

📙 이것이 코딩 테스트다<br>
https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC<br>
https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/quick-sort<br>
